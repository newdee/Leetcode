# 914.X of a Kind in a Deck of Cards
> 给定一副牌，每张牌上都写着一个整数。
此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
每组都有 X 张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回 true。

示例 1：
```
输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
```
示例 2：
```
输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。
```
示例 3：
```
输入：[1]
输出：false
解释：没有满足要求的分组。
```
示例 4：
```
输入：[1,1]
输出：true
解释：可行的分组是 [1,1]
```
示例 5：
```
输入：[1,1,2,2,2,2]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[2,2]
```
提示：
```
1 <= deck.length <= 10000
0 <= deck[i] < 10000
```

方法：由于每个数都小于10000，所以直接创建一个0-10000的数组，用来统计每个数出现的次数。  
然后从2开始（因为X>=2），如果有一个数只出现了一次，则返回false，然后循环，如果遍历结束后，所有的数模i都为0，即出现次数为0或者i的倍数，则该数组满足条件。因为X>=2，所以i的大小不会超过size/2-1。当所有i遍历结束后还没有返回值，则说明不存在这样的X，返回false。
```
class Solution {
public:
    bool hasGroupsSizeX(vector<int>& deck) {
        vector<int > num(10000,0);
        int size = deck.size();
        for(int i=0;i<size;i++)
            num[deck[i]]++;

        for(int i=2;i<=size/2+1;i++)
        {
            int j=0;
            for(; j<10000;j++)

            {
                if(num[j] ==1 )
                    return false;
                else if(num[j]%i)
                    break;
            }
        if(j == 10000) return true;
    }
    return false;
    }

};
```
