[To Index](/index.md)
---
# 989.Add to Array-Form of Integer
难度:Easy
>For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1].

Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.

 

```
Example 1:

Input: A = [1,2,0,0], K = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234
Example 2:

Input: A = [2,7,4], K = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455
Example 3:

Input: A = [2,1,5], K = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021
Example 4:

Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000
 

Note：

1 <= A.length <= 10000
0 <= A[i] <= 9
0 <= K <= 10000
If A.length > 1, then A[0] != 0
```

可以全部轉化成string，然後計算加法，這樣不會溢出，不過運行時間較長。另一種方法是，對K每加一位，再向前更新。  
```
class Solution {
public:
    vector<int> addToArrayForm(vector<int>& A, int K) {
        if(K==0) return A;
        bool flag=false;
        for(int i=A.size()-1;i>=0;i--)
        {
            if(K){
            K+=A[i];
            A[i]=K%10;
            K/=10;
            }
            else 
            {
                flag=true;
                break;
            }
        }
       // cout<<flag<<endl;
        if(flag || K==0) return A;
        int len=log10(K)+1;
        vector<int >res(len+A.size(),0);
        for(int i=len-1;i>=0;i--)
        {
            res[i]=K%10;
            K/=10;
        }
        for(int i=len;i<res.size();i++)
            res[i]=A[i-len];
        return res;
        
    }
};
```
從個位算起，與K相加，將和的個位留在該位置，然後和除以10，繼續向前移位相加。   
其中，flag表示在計算求和過程中，K如果爲0，則不必向高位繼續計算，直接返回A矩陣。  
然後計算遍歷完A之後K的大小，將其轉化爲矩陣並與A合併得最終結果。  

> 执行用时 :164 ms, 在所有 C++ 提交中击败了91.72%的用户   
内存消耗 :12.4 MB, 在所有 C++ 提交中击败了84.39%的用户
